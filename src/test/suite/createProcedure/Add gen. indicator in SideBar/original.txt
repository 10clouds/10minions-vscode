import * as React from "react";
import { createRoot } from "react-dom/client";
import { MessageToVSCode, MessageToWebView } from "../Messages";
import { ApiKeyInfoMessage } from "./ApiKeyInfoMessage";
import { GoButton } from "./GoButton";
import { Header } from "./Header";
import { Logo } from "./Logo";
import { ALL_MINION_ICONS_OUTLINE } from "./MinionIconsOutline";
import { MinionTaskListComponent } from "./MinionTaskListComponent";
import { MinionTaskUIInfo } from "./MinionTaskUIInfo";
import { useTemporaryFlag } from "./useTemporaryFlag";

declare const acquireVsCodeApi: any;

const vscode = acquireVsCodeApi();

export function postMessageToVsCode(message: MessageToVSCode) {
  vscode.postMessage(message);
}

export const SideBarWebViewInnerComponent: React.FC = () => {
  const [userInputPrompt, setUserInputPrompt] = React.useState("");
  const [executionList, setExecutionList] = React.useState<MinionTaskUIInfo[]>([]);
  const [apiKeySet, setApiKeySet] = React.useState<true | false | undefined>(undefined);
  const [selectedSuggestion, setSelectedSuggestion] = React.useState("");
  const [justClickedGo, markJustClickedGo] = useTemporaryFlag();
  const [isSidebarVisible, setIsSidebarVisible] = React.useState(true);

  const [selectedText, setSelectedText] = React.useState("");
  const [suggestionInputBase, setSuggestionInputBase] = React.useState("");
  const [suggestionSelectedTextBase, setSuggestionSelectedTextBase] = React.useState("");

  const timeoutRef = React.useRef<NodeJS.Timeout | null>(null);

  function resetSuggestions() {
    setSelectedSuggestion("");
    setSuggestionInputBase("");
    setSuggestionSelectedTextBase("");

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
  }

  function requestSuggestions() {
    if (selectedSuggestion !== "" && suggestionInputBase === userInputPrompt && suggestionSelectedTextBase === selectedText) {
      return;
    }

    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    setSuggestionInputBase(userInputPrompt);
    setSuggestionSelectedTextBase(selectedText);

    if (selectedSuggestion === "") {
      console.log("get suggestions");
      postMessageToVsCode({
        type: "getSuggestions",
        input: userInputPrompt,
      });
    } else {
      function getCurrentInputValue() {
        // Use textAreaRef to access the textarea element value directly
        if (textAreaRef.current) {
          return textAreaRef.current.value;
        }

        // Fallback to the state
        return userInputPrompt;
      }

      timeoutRef.current = setTimeout(() => {
        // Get the updated userInputPrompt value
        const updatedUserInputPrompt = getCurrentInputValue();

        console.log("get suggestions");
        postMessageToVsCode({
          type: "getSuggestions",
          input: updatedUserInputPrompt,
        });
      }, 1500);
    }
  }

  function handleMessage(message: MessageToWebView) {
    console.log("CMD (webview)", message.type);

    switch (message.type) {
      case "clearAndfocusOnInput":
        handleClearAndFocus();
        break;
      case "executionsUpdated":
        handleExecutionsUpdated(message.executions);
        break;
      case "apiKeySet":
        setApiKeySet(message.value);
        break;
      case "updateSidebarVisibility":
        setIsSidebarVisible(message.value);
        if (isSidebarVisible) {
          requestSuggestions();
        }
        break;
      case "suggestion":
        setSelectedSuggestion(message.value || "");
        break;
      case "selectedTextUpdated":
        setSelectedText(message.selectedText);
        if (isSidebarVisible) {
          resetSuggestions();
        }
        break;
    }
  }

  function handleClearAndFocus() {
    setUserInputPrompt("");
    const input = document.querySelector("textarea");
    input?.focus();
  }

  function handleExecutionsUpdated(executions: MinionTaskUIInfo[]) {
    setExecutionList(executions);
  }

  function handleSuggestionClick(command: string) {
    setUserInputPrompt(command);
    setSelectedSuggestion("");
  }

  React.useEffect(() => {
    const eventHandler = (event: any) => {
      const message: MessageToWebView = event.data;
      handleMessage(message);
    };

    window.addEventListener("message", eventHandler);

    postMessageToVsCode({ type: "readyForMessages" });

    return () => {
      window.removeEventListener("message", eventHandler);
    };
  }, []);

  function handleTextAreaChange(e: React.ChangeEvent<HTMLTextAreaElement>) {
    setUserInputPrompt(e.target.value);
    if (!selectedSuggestion.includes(e.target.value)) setSelectedSuggestion("");
    if (e.target.value === "") setSelectedSuggestion("");

    requestSuggestions();
  }

  //get two random different robot icons
  const [RobotIcon1, RobotIcon2] = React.useMemo(() => {
    const randomIndex = Math.floor(Math.random() * ALL_MINION_ICONS_OUTLINE.length);
    return [ALL_MINION_ICONS_OUTLINE[randomIndex], ALL_MINION_ICONS_OUTLINE[(randomIndex + 1) % ALL_MINION_ICONS_OUTLINE.length]];
  }, []);

  const textAreaRef = React.useRef<HTMLTextAreaElement>(null);

  React.useEffect(() => {
    requestSuggestions();
  }, []);

  const [isTextAreaFocused, setIsTextAreaFocused] = React.useState(false);

  return (
    <div className="w-full">
      <div className="p-4 mb-16">
        <Header RobotIcon1={RobotIcon1} RobotIcon2={RobotIcon2} />

        {apiKeySet === false && <ApiKeyInfoMessage />}

        {apiKeySet === true && (
          <>
            <div className="mb-2">
              Summon a Minion! Jot down your coding task and delegate to your loyal Minion. Remember, each Minion lives in a context of a specific file. For
              pinpoint precision, select the code involved.{" "}
            </div>
            <div style={{ position: "relative" }}>
              <div
                style={{
                  display: "flex",
                  flexDirection: "column",
                  position: "relative",
                }}
              >
                <div
                  style={{
                    display: "flex",
                    flexDirection: "row",
                    flexWrap: "wrap",
                    color: "rgba(var(--vscode-editor-foreground), 0.5)", // Grayed-out text color
                    alignItems: "baseline",
                  }}
                >
                  <textarea
                    ref={textAreaRef}
                    style={{
                      position: "relative",
                      height: "10rem",
                      backgroundColor: "var(--vscode-editor-background)",
                      color: "rgba(0,0,0,100)",
                      borderColor: "var(--vscode-focusBorder)",
                      caretColor: "var(--vscode-editor-foreground)",
                    }}
                    className="w-full h-96 mb-3 p-4 text-sm resize-none focus:outline-none"
                    value={userInputPrompt}
                    onChange={handleTextAreaChange}
                    onInput={handleTextAreaChange}
                    onFocus={() => {
                      setIsTextAreaFocused(true);
                      requestSuggestions();
                    }}
                    onBlur={() => {
                      setIsTextAreaFocused(false);
                      resetSuggestions();
                    }}
                    onKeyDown={(e) => {
                      // Check for Tab key and if the selectedSuggestion is valid
                      if (e.key === "Tab" && selectedSuggestion.length > 0) {
                        e.preventDefault(); // Prevent default tab behavior
                        handleSuggestionClick(selectedSuggestion);
                      }
                      // Check for Enter key and if the Shift key is NOT pressed
                      else if (e.key === "Enter" && !e.shiftKey) {
                        e.preventDefault(); // Prevent default line break behavior

                        if (justClickedGo) return; // Prevent double submission
                        // Submit userInputPrompt by calling postMessageToVsCode function
                        postMessageToVsCode({
                          type: "newExecution",
                          value: userInputPrompt,
                        });

                        markJustClickedGo();

                        // Clear user input when "Enter" key is pressed
                        setUserInputPrompt(""); // <- Added this line to clear input
                      }
                    }}
                  />

                  <div
                    style={{
                      position: "absolute",
                      top: 0,
                      left: 0,
                      height: "10rem",
                      pointerEvents: "none",
                      color: "rgba(var(--vscode-editor-foreground), 0.5)",
                      overflow: "hidden",
                      whiteSpace: "pre-wrap",
                      zIndex: 1000,
                    }}
                    className="w-full h-96 p-4 text-sm resize-none focus:outline-none pointer-events-none"
                  >
                    <span style={{ opacity: 1.0 }}>{userInputPrompt}</span>
                    {userInputPrompt !== "" && isTextAreaFocused && selectedSuggestion && (
                      <>
                        <br />
                        <br />
                      </>
                    )}
                    {userInputPrompt !== "" && selectedSuggestion && isTextAreaFocused && (
                      <span style={{ opacity: 0.5 }}>
                        Suggestion:
                        <br />
                      </span>
                    )}
                    {selectedSuggestion && <span style={{ opacity: 0.7 }}>{selectedSuggestion}</span>}
                    <br />
                    {selectedSuggestion && isTextAreaFocused && <span style={{ opacity: 0.5 }}>Press Tab to accept suggestion</span>}
                  </div>
                </div>
                <GoButton
                  onClick={() => {
                    postMessageToVsCode({
                      type: "newExecution",
                      value: userInputPrompt,
                    });
                    markJustClickedGo();
                    setUserInputPrompt("");
                  }}
                  justClickedGo={justClickedGo}
                />

                <MinionTaskListComponent executionList={executionList} />
              </div>
            </div>
          </>
        )}
      </div>
      <div
        // Update className to achieve better centering, margin, padding, and width
        className="text-center py-4 fixed bottom-0 w-full"
        key="credits"
        style={{
          backgroundColor: "var(--vscode-sideBar-background)",
          zIndex: 1000,
        }}
      >
        <a className="inline-block w-20 logo" href="https://10clouds.com" target="_blank" rel="noopener noreferrer">
          by <br />
          <Logo className="inline-block w-20" alt="10Clouds Logo" />
        </a>
      </div>
    </div>
  );
};

const container = document.getElementById("root");
const root = createRoot(container!);
root.render(<SideBarWebViewInnerComponent />);

/*
Recently applied task: Update userInputPrompt variable to reflect the current input before calling postMessageToVsCode function.

You can not accept it via parameter
*/

/*
Recently applied task: Shrink the textarea and associated div by 2
*/

/*
Recently applied task: Check if there is a more updated or optimal version of the acquireVsCodeApi function available and make any necessary updates.
*/

/*
Recently applied task: Add functionality to clear user input when the "Enter" key is pressed.
*/

/*
Recently applied task: Update the link URL to match the current 10Clouds website, and add an alt tag to the logo for improved accessibility.
*/

/*
Recently applied task: Optimize userInputPrompt retrieval
*/
