I will create a new state variable called "loadingSuggestion" which will be true when we request suggestions and will be set to false when we receive a suggestion or if an error occurs. Next, I will update the "requestSuggestions" function to set "loadingSuggestion" to true when starting and to set it to false upon receiving suggestions. Then, in the text area, I will conditionally display a loading indication based on the state of "loadingSuggestion".

REPLACE
const [loadingSuggestion, setLoadingSuggestion] = React.useState(false);
WITH
const [loadingSuggestion, setLoadingSuggestion] = React.useState(false);

REPLACE
function requestSuggestions() {
  if (selectedSuggestion !== "" && suggestionInputBase === userInputPrompt && suggestionSelectedTextBase === selectedText) {
    return;
  }

  if (timeoutRef.current) {
    clearTimeout(timeoutRef.current);
  }

  setLoadingSuggestion(true); // Set loadingSuggestion to true when starting

  setSuggestionInputBase(userInputPrompt);
  setSuggestionSelectedTextBase(selectedText);

  if (selectedSuggestion === "") {
    console.log("get suggestions");
    postMessageToVsCode({
      type: "getSuggestions",
      input: userInputPrompt,
    });
  } else {
    function getUpdatedUserInputPrompt() {
      // Get the current value of the textarea
      const input = document.querySelector("textarea");
      if (input) {
        return input.value;
      }

      // Fallback to the state
      return userInputPrompt;
    }

    timeoutRef.current = setTimeout(() => {
      // Get the updated userInputPrompt value
      const updatedUserInputPrompt = getUpdatedUserInputPrompt();

      console.log("get suggestions");
      postMessageToVsCode({
        type: "getSuggestions",
        input: updatedUserInputPrompt,
      });
    }, 1500);
  }
}
WITH
function requestSuggestions() {
  if (selectedSuggestion !== "" && suggestionInputBase === userInputPrompt && suggestionSelectedTextBase === selectedText) {
    return;
  }

  if (timeoutRef.current) {
    clearTimeout(timeoutRef.current);
  }

  setLoadingSuggestion(true); // Set loadingSuggestion to true when starting

  setSuggestionInputBase(userInputPrompt);
  setSuggestionSelectedTextBase(selectedText);

  if (selectedSuggestion === "") {
    console.log("get suggestions");
    postMessageToVsCode({
      type: "getSuggestions",
      input: userInputPrompt,
    });
  } else {
    function getUpdatedUserInputPrompt() {
      // Get the current value of the textarea
      const input = document.querySelector("textarea");
      if (input) {
        return input.value;
      }

      // Fallback to the state
      return userInputPrompt;
    }

    timeoutRef.current = setTimeout(() => {
      // Get the updated userInputPrompt value
      const updatedUserInputPrompt = getUpdatedUserInputPrompt();

      console.log("get suggestions");
      postMessageToVsCode({
        type: "getSuggestions",
        input: updatedUserInputPrompt,
      });
    }, 1500);
  }
}

REPLACE
function handleMessage(message: MessageToWebView) {
  console.log("CMD (webview)", message.type);

  setLoadingSuggestion(false); // Set loadingSuggestion to false upon receiving message

  switch (message.type) {
    ...
  }
}
WITH
function handleMessage(message: MessageToWebView) {
  console.log("CMD (webview)", message.type);

  setLoadingSuggestion(false); // Set loadingSuggestion to false upon receiving message

  switch (message.type) {
    ...
  }
}

REPLACE
{
  userInputPrompt !== "" &&
  isTextAreaFocused &&
  loadingSuggestion && <span style={{ opacity: 0.5 }}>Generating suggestion...</span>;
}
WITH
{
  userInputPrompt !== "" &&
  isTextAreaFocused &&
  loadingSuggestion && <span style={{ opacity: 0.5 }}>Generating suggestion...</span>;
}
END_REPLACE